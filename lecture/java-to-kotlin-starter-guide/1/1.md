---
description: 1강 - 코틀린에서 변수를 다루는 방법을 정리한 내용입니다.
---

# 1강 - 코틀린에서 변수를 다루는 방법

## 자바 코드

{% tabs %}
{% tab title="code1" %}
<pre class="language-java"><code class="lang-java"><strong>public class Lec01Main {
</strong>
    public static void main(String[] args) {
        long number1 = 10L; // (1)
        final long number2 = 10L; // (2)

        Long number3 = 1_000L; // (3)
        Person person = new Person("이름"); // (4)

        final List&#x3C;Integer> numbers = Arrays.asList(1, 2);
        numbers = Arrays.asList(2, 3); // 컴파일 에러
        numbers.add(3);
    }

}

</code></pre>
{% endtab %}

{% tab title="code2" %}
```java
public class Person {

    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
    
}

```
{% endtab %}
{% endtabs %}

## 1. 변수 선언 키워드 - var과 val의 차이점

* 자바에서의 일반 변수와 final 붙은 변수의 차이와 동일하다. (값을 할당 받고 재할당 가능한지 여부이다)
* var는 가변이고 val은 불변과 비슷하다. (완전한 불변은 아니고 읽기 전용이다)

{% tabs %}
{% tab title="code" %}
```kotlin
var number1 = 10L
number1 = 5L

val number2 = 10L
number2 = 5L // 컴파일 에러
```
{% endtab %}
{% endtabs %}

```
- val은 한번 값이 할당되면 그 이후에 재할당 하려고 할때 컴파일 에러가 난다.
```

* 선언시 타입은 명시적으로 선언해도 되고, 컴파일러 타입 추론에 맡겨도 된다.

{% tabs %}
{% tab title="code" %}
```kotlin
var number1 = 10L
var number2: Long = 10L
```
{% endtab %}
{% endtabs %}

* 초기값을 지정해 주지 않으면 선언 자체는 에러가 나지 않지만 사용할때 에러가 난다.

{% tabs %}
{% tab title="code1" %}
```kotlin
var number1 // 컴파일 에러

val number2 // 컴파일 에러
```
{% endtab %}

{% tab title="code2" %}
```kotlin
var number1: Long 
println(number1) // 컴파일 에러 (초기화 되지 않은 값은 사용할 수 없다)

val number2: Long
println(number2) // 컴파일 에러 (초기화 되지 않은 값은 사용할 수 없다)
```
{% endtab %}

{% tab title="code3" %}
```kotlin
var number1: Long
number1 = 5L
println(number1)

val number2: Long
number2 = 5L // val 변수는 최초 한번은 값 할당이 가능하다.
println(number2)
```
{% endtab %}
{% endtabs %}

* val 은 자바의 final 처럼 참조값은 수정할 수 없으나 참조 컬렉션의 요소는 수정 가능하다.

{% tabs %}
{% tab title="code" %}
```kotlin
val numbers = mutableListOf(1, 2)
numbers.add(3)
numbers = mutableListOf(2, 3) // 컴파일 에러
```
{% endtab %}
{% endtabs %}

* 모든 변수는 val로 만들고 꼭 필요한 경우만 var로 변경한다.

## 2. 코틀린에서의 원시 타입(primitive type)

* 자바에서는 연산시 불필요한 Unboxing, Boxing의 성능 저하 때문에 레퍼런스 타입을 지양한다.
* 자바와는 다르게 코틀린에서는 원시 타입과 레퍼런스 타입의 선언이 구분되어 있지 않다.

{% tabs %}
{% tab title="code" %}
```kotlin
var number1: Long = 10L
```
{% endtab %}
{% endtabs %}

```
- 내부적으로 연산 실행시에는 원시 타입으로 바꿔서 실행한다.
- Intellij 툴에서 디컴파일을 해보면 자바의 원시 타입으로 선언되어 있는걸 확인 할 수 있다.
```

## 3. 코틀린에서의 nullable 변수

* 자바의 레퍼런스 타입은 원시 타입에는 할당할 수 없는 null을 할당할 수 있다.
* 코틀린은 레퍼런스 타입 형태이지만 자바처럼 null을 할당할 수 없다.
* 코틀린에서 null을 할당하기 위해서는 타입? 키워드를 사용해야 한다.

{% tabs %}
{% tab title="code1" %}
```kotlin
var number3 = 1_000L
number3 = null // 컴파일 에러
```
{% endtab %}

{% tab title="code2" %}
```kotlin
var number3: Long? = 1_000L
number3 = null
```
{% endtab %}
{% endtabs %}

## 4. 코틀린에서의 객체 인스턴스화

* 코틀린에서 객체를 인스턴스화 할때 new 키워드를 사용하지 않는다.

{% tabs %}
{% tab title="code" %}
```kotlin
var person = Person("이름")
```
{% endtab %}
{% endtabs %}

## 정리

> 모든 변수는 var(변경가능) / val(변경불가, 읽기전용) 을 붙여 주어야 한다.
>
> 타입을 명시적으로 선언하지 않아도 할당되는 값으로 타입을 추론한다.
>
> 원시 타입(primitive type)과 레퍼런스 타입(reference type)을 구분하지 않아도 된다.
>
> null이 들어가는 변수는 타입? 키워드로 선언해주어야 하고 다른 타입으로 간주된다.
>
> 객체를 인스턴스화 할때 new 키워드를 붙이지 않아도 된다.
