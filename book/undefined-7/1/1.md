---
description: 아이템 1 - 가변성을 제한하라를 정리한 내용입니다.
---

# 아이템 1 - 가변성을 제한하라

* 코틀린은 var, mutable 객체를 사용하여 상태(state)를 가질 수 있다.

{% tabs %}
{% tab title="code1" %}
```kotlin
var a = 10
var list: MutableList<Int> = mutableListOf()
```
{% endtab %}
{% endtabs %}

* 특정 요소가 상태를 가지게 되면 그 이력(history)에 의존하게 된다.

{% tabs %}
{% tab title="code1" %}
```kotlin
class BankAccount {
  var balance = 0.0
    private set
    
  fun deposit(depositAmount: Double) {
    balance += depositAmount
  }
  
  @Throws(InsufficientFunds::class)
  fun withdraw(withdrawAmount: Double) {
    if (balance < withdrawAmount) {
      throw InsufficientFunds()
    }
    balance -= withdrawAmount
  }
}

class InsufficientFunds : Exception()

val account = BankAccount()
println(account.balance) // 0.0
  
account.deposit(100.0)
println(account.balance) // 100.0
  
account.withdraw(50.0)
println(account.balance) // 50.0
```
{% endtab %}
{% endtabs %}

* 상태를 시간 변화에 따른 요소를 표현하여 유용하지만, 적절하게 관리하는 것은 생각보다 꽤 어렵다.

```
1. 상태 변겨에 따른 추적과 관계의 이해가 필요해 프로그램을 이해하고 디버깅하기 힘들어진다.
2. 특정 시점에 따라 값이 달라질 수 있으므로 코드의 실행을 추론하기 어려워진다.
3. 멀티스레드 환경에서는 적절한 동기화가 필요하다.
4. 특정 상황에 따라 변경되는 값이므로 테스트하기가 어렵다.
5. 상태 변경에 따른 노티를 해줘야 하는 경우가 필요하다.
```

* 멀티스레드에서 공유 상태를 관리하는게 힘들 수 있는 부분을 예로 확인한다.

{% tabs %}
{% tab title="code1" %}
```kotlin
var num = 0
for (i in 1..1000) {
  thread {
    Thread.sleep(10)
    num += 1
  }
}
Thread.sleep(5000)
print(num) // 1000이 아닐 확률이 매우 높다.
// 실행할 때마다 다른 숫자가 나온다.
```
{% endtab %}

{% tab title="code2" %}
```kotlin
suspend fun main() {
  var num = 0
  coroutineScope {
    for (i in 1..1000) {
      launch {
        delay(10)
        num += 1
      }
    }
  }
  print(num) // 1000이 아닐 확률이 매우 높다.
}
```
{% endtab %}

{% tab title="code3" %}
<pre class="language-kotlin"><code class="lang-kotlin"><strong>val lock = Any()
</strong>var num = 0
for (i in 1..1000) {
  thread {
    Thread.sleep(10)
    synchronized(lock) {
      num += 1
    }
  }
}
Thread.sleep(5000)
print(num) // 1000
</code></pre>
{% endtab %}
{% endtabs %}

```
- 일부 연산이 충돌되어 사라지므로 적절하게 동기화를 구현해야 한다.
- 가변성은 단점이 많고, 이를 제한하는 순수 함수형 언어가 있긴 하나 프로그램을 작성하기가 어렵다.
```

## 코틀린에서 가변성 제한하기

* 코틀린은 가변성을 제한할 수 있게 설계되어 있다.
* 가변성 제한으로 불변(immutable) 객체를 만들거나 프로퍼티를 변경할 수 없게 막는 것이 쉽다.

### 읽기 전용 프로퍼티(val)

* 코틀린은 val를 사용해 읽기 전용 프로퍼티를 만들 수 있다.

{% tabs %}
{% tab title="code1" %}
```kotlin
val a = 10
a = 20 // 오류
```
{% endtab %}
{% endtabs %}

* 읽기 전용 프로퍼티가 완전히 변경 불가능하다는 의미는 아니다.
* 읽기 전용 프로퍼티가 mutable 객체를 담고 있다면 내부적으로는 변경할 수 있다.

{% tabs %}
{% tab title="code1" %}
```kotlin
val list = mutableListOf(1, 2, 3)
list.add(4)

print(list) // [1, 2, 3, 4]
```
{% endtab %}
{% endtabs %}

* 읽기 전용 프로퍼티가 var 프로퍼티를 사용하는 게터로 정의될때 변할 수 있다.

{% tabs %}
{% tab title="code1" %}
```kotlin
var name: String = "Marcin"
var surname: String = "Moskata"
val fullName
  get() = "$name $surname"

fun main() {
  println(fullName) // Marcin Moskata
  name = "Maja"
  println(fullName) // Maja Moskata
}
```
{% endtab %}

{% tab title="code2" %}
```kotlin
fun calculate(): Int {
  print("Calculating...")
  return 42
}

val fizz = calculate() // 계산합니다...
val buzz
  get() = calculate()

fun main() {
  print(fizz) // 42
  print(fizz) // 42
  print(buzz) // 계산합니다... 42
  print(buzz) // 계산합니다... 42
}
```
{% endtab %}
{% endtabs %}

* var는 게터와 세터를 모두 제공하지만 val은 변경이 불가능하므로 게터만 제공한다.
* 게터만을 제공하는 val을 게터, 세터 모두 제공하는 var로 오버라이드 할 수 있다.

{% tabs %}
{% tab title="code1" %}
```kotlin
interface Element {
  val active: Boolean
}

class ActualElement : Element {
  override var active: Boolean = false
}
```
{% endtab %}
{% endtabs %}

* val은 값은 변경되나 레퍼런스 자체는 변경불가므로 동기화 문제를 줄일 수 있다.
* val은 읽기 전용 프로퍼티이지, 변경할 수 없음인 불변(immutable)을 의미하는 것은 아니다.

{% tabs %}
{% tab title="code1" %}
```kotlin
val name: String? = "Marton"
val surname: String = "Braun"

val fullName: String?
  get() = name?.let { "$it $surname" }

val fullName2: String? = name?.let { "$it $surname" }

fun main() {
  if (fullName != null) {
    println(fullName.length) // 오류
  }

  if (fullName2 != null) {
    println(fullName2.length) // Marton Braun
  }
}

```
{% endtab %}
{% endtabs %}

```
- fullName은 게터 사용시 값 사용시점의 name에 따라 결과가 달라지므로 스마트 캐스를 사용할 수 없다.
- fullName2 처럼 지역변수가 아닌 프로퍼티가 final이고 사용자 게터가 아닌경우 스마트 캐스트가 가능하다.
```

### 가변 컬렉션과 읽기 전용 컬렉션 구분하기

* 코틀린은 읽고 쓸 수 있는 프로퍼티와 읽기 전용 프로퍼티로 구분된다.
* 코틀린은 읽고 쓸 수 있는 컬렉션과 읽기 전용 컬렉션으로 구분된다.

| 읽기 전용 컬렉션 인터페이스 | 읽고 쓸 수 있는 컬렉션     |
| --------------- | ----------------- |
| Iterable        | MutableIterable   |
| Collection      | MutableCollection |
| Set             | MutableSet        |
| List            | MutableList       |

```
- 읽고 쓸 수 있는 컬렉션은 읽기 전용 인테페이스를 상속받아 변경 메서드를 추가했다.
```

* 읽기 전용 컬렉션도 내부의 값을 변경할 수 없다는 의미는 아니다.
* 읽기 전용 컬렉션의 전용 인터페이스가 변경을 지원하지 않아서 변경할 수 없는 것이다.

{% tabs %}
{% tab title="code1" %}
```kotlin
inline fun <T, R> Iterable<T>.map(
  transformation: (T) -> R
): List<R> {
  val list = ArrayList<R>()
  for (elem in this) {
    list.add(transformation(elem))
  }
  return list
}
```
{% endtab %}
{% endtabs %}

```
- Iterable는 읽기 전용 컬렉션이나 내부의 map 함수는 변경할 수 있는 리스트인 ArrayList를 반환한다.
```

* 코틀린은 Iterable를 진짜 불변(immutable)이 아닌 읽기 전용의 의미를 가진다.
* 읽기 전용 컬렉션은 진짜 불변이 아니기 때문에 다운캐스팅시 예측하지 못하는 결과를 초래한다.

{% tabs %}
{% tab title="code1" %}
```kotlin
val list = listOf(1, 2, 3)

// 이렇게 하지 마세요!
if (list is MutableList) {
  list.add(4)
}
```
{% endtab %}
{% endtabs %}

```
- 상황에 따라 구현체가 Arrays.ArrayList 이면 UnsupportedOperationException이 발생할 수 있다.
```

* 읽기 전용 컬렉션을 Mutable로 변경시 copy를 통해 새로운 컬렉션을 만들어야 한다.

{% tabs %}
{% tab title="code1" %}
```kotlin
val list = listOf(1, 2, 3)

val mutableList = list.toMutableList()
mutableList.add(4)
```
{% endtab %}
{% endtabs %}

### 데이터 클래스의 copy

* immutable 객체를 사용하면 여러가지 장점이 있다.

```
1. 한 번 정의된 상태가 유지되므로, 이해하기 쉽다.
2. 병렬처리를 안전하게 할 수 있다.
3. 변경되지 않으므로 캐시할 수 있다.
4. 방어적 복사 및 깊은 복사를 하지 않아도 된다.
5. 객체를 통해 다른 객체를 만들기와 실행 예측이 쉽다.
6. set, map의 키로 사용할 수 있다. 
(set, map 내부적으로 해시 테이블을 사용, 해시 테이블은 처음 요소 값 기반으로 버킷을 결정한다)
```

{% tabs %}
{% tab title="code1" %}
```kotlin
val names: SortedSet<FullName> = TreeSet()
val person = FullName("AAA", "AAA")
names.add(person)
names.add(FullName("Jordan", "Hansen"))
names.add(FullName("David", "Blanc"))

print(names) // [AAA AAA, David Blanc, Jordan Hansen]
print(person in names) // true

person.name = "ZZZ"
print(names) // [ZZZ AAA, David Blanc, Jordan Hansen]
print(person in names) // false
```
{% endtab %}
{% endtabs %}

```
- 마지막 출력은 객체가 내부에 있음에도 false를 리턴한다.
- 객체를 변경했기 때문에 찾을 수가 없는 것이다. (객체 수정시 해시 테이블에서 요소를 찾을 수가 없다)
```

* mutable 객체는 예측하기 어렵다.
* immutable 객체는 변경할 수 없고, 변경 필요시 수정된 새로운 객체를 만들어 내는 메서드를 가져야 한다.
* Int는 immutable 객체로 plus, minus, map, filter... 사용시 새로운 객체를 리턴한다.
* 사용자 immutable 객체도 Int 처럼 비슷하게 작동해야 한다.
* User라는 immutable 객체가 있고, 성을 변경해야 할때 withSurname 같은 메서드를 제공해야 한다.

{% tabs %}
{% tab title="code1" %}
```kotlin
class User(

```
{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="code1" %}
```kotlin
class User(
  val name: String,
  val surname: String
) {
  fun withSurname(surname: String) = User(name, surname)
}

var user = User("Maja", "Markiewicz")
user = user.withSurname("Moskata")
print(user) // User(name=Maja, surname=Moskata)
```
{% endtab %}

{% tab title="code2" %}
```kotlin
data class User(
  val name: String,
  val surname: String
)

var user = User("Maja", "Markiewicz")
user = user.copy(surname = "Moskata")
print(user) // User(name=Maja, surname=Moskata)
```
{% endtab %}
{% endtabs %}

```
- User라는 immutable 객체의 내부 값 변경시 withSurname 같은 객체 생성 메서드를 제공해야 한다.
- data class는 copy 메서드를 활용해 새로운 객체를 편하게 만들 수 있는 기능을 제공한다.
- mutable 객체보다는 immutable 객체가 여러가지 장점을 많이 가지므로 기본적으로 이렇게 만드는게 좋다.
```

## 다른 종류의 변경 가능 지점

* 변경할 수 있는 리스트를 만들때 변경 지점이 다른 mutable 컬렉션과 var 프로퍼티 형태로 만들 수 있다.

{% tabs %}
{% tab title="code1" %}
```kotlin
val list1: MutableList<Int> = mutableListOf()
var list2: List<Int> = listOf()
```

* 두 형태 모두 변경은 가능하나 방법이 다르다.

```kotlin
list1.add(1)
list2 = list2 + 1
```

* 방법이 같은 형태로 += 연산자를 활용해서 변경가능하나 내부적 처리는 역시 다르다

```kotlin
list1 += 1 // list1.plusAssign(1)로 변경된다.
list2 += 1 // list2 = list2.plus(1)로 변경된다.
```

```kotlin
var list = listOf<Int>()
for (i in 1..1000) {
  thread {
    list = list + i
  }
}
Thread.sleep(1000)
print(list.size) // 1000이 되지 않는다.
// 실행할 때마다 다른 숫자가 나온다.
```
{% endtab %}
{% endtabs %}

```
- 두 형태 모두 동작은 동일하지만 변경 가능 지점의 위치가 다르다.
- list1은 구체적인 리스트 구현 내부에 변경 가능 지점이 있다.
- list2는 프로퍼티 자체가 변경 가능 지점이다.
- list1은 멀티스레드 환경에서 내부의 적절한 동기화 여부를 알 수 없어서 위험하고 상대적으로 list2는 안전하다.
- list2도 잘못 구현하면 멀티스레드 환경에서 엉뚱한 결과를 낸다.
```

* mutable 컬렉션이 아닌 var 프로퍼티 형태는 변경을 추적할 수 있다.

{% tabs %}
{% tab title="code1" %}
```kotlin
var names by Delegates.observable(listOf<String>()) { _, old, new ->
  println("Names changed from $old to $new")
}

names += "Fabio"
// names가 []에서 [Fabio]로 변환된다.
names += "Bill"
// names가 [Fabio]에서 [Fabio, Bill]로 변환된다.
```
{% endtab %}
{% endtabs %}

* mutable 컬렉션은 관찰할 수 있게 하려면 추가적인 구현이 필요하다.
* var 프로퍼티에 읽기 전용 컬렉션 형태를 넣어 사용하는것이 객체 변경 제어가 더 쉽다.
* 프로퍼티와 컬렉션을 모두 변경 가능하게 만드는 방식은 사용하지 말아야 한다

{% tabs %}
{% tab title="code1" %}
```kotlin
var announcements = listOf<Announcement>()
  private set

```

```kotlin
// 이렇게 하지 마세요.
var list3 = mutableListOf<Int>()
```
{% endtab %}
{% endtabs %}

```
- 변경될 수 있는 두 지점 모두에 동기화 구현이 필요하다.
- 모호성이 발생하여 += 를 사용할 수 없다.
```

* 불필요한 변경 지점을 만들지 말고 가능한 가변성을 제한하는 것이 좋다.

## 변경 가능 지점 노출하지 말기

* 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 위험하다.

{% tabs %}
{% tab title="code1" %}
```kotlin
data class User(val name: String)

class UserRepository {
  private val storedUsers: MutableMap<Int, String> = mutableMapOf()
  
  fun loadAll(): MutableMap<Int, String> {
    return storedUsers
  }
  
  // ...
}

val userRepository = UserRepository()

val storedUsers = userRepository.loadAll()
storedUsers[4] = "Kirill"
// ...

print(userRepository.loadAll()) // {4=Kirill}
```
{% endtab %}
{% endtabs %}

```
- loadAll을 사용해서 private 상태인 UserRepository를 수정할 수 있다.
```

* 방어적 복제(defensive copying) 혹은 가변성을 제한해서 이를 막을 수 있다.

{% tabs %}
{% tab title="code1" %}
```kotlin
class UserHolder {
  private val user: MutableUser()
  
  fun get(): MutableUser {
    return user.copy()
  }
  
  // ...
}
```
{% endtab %}

{% tab title="code2" %}
```kotlin
data class User(val name: String)

class UserRepository {
  private val storedUsers: MutableMap<Int, String> = mutableMapOf()
  
  fun loadAll(): Map<Int, String> {
    return storedUsers
  }
  
  // ...
}
```
{% endtab %}
{% endtabs %}

## 정리

> var보다는 val를 사용하는 것이 좋다.
>
> mutable 프로퍼티보다는 immutable 프로퍼티를 사용하는 것이 좋다.
>
> mutable 객체와 클래스보다 immutable 객체와 클래스를 사용하는것이 좋다.
>
> 변경이 필요할시 immutable 데이터 클래스로 만들고 copy를 활용하는것이 좋다.
>
> 컬렉션 상태 저장시 mutable 컬랙션보다 읽기 전용 컬렉션을 사용하는 것이 좋다.
>
> 불필요한 변이 지점을 만들지 않는 것이 좋다.
>
> mutable 객체를 외부에 노출하지 않는 것이 좋다.

* immutable 객체와 mutable 객체를 구분하는 기준은 가변성이다.
